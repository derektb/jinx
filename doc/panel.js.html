<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: panel.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: panel.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
--- TWIZE PANEL ---
 An object which stores the Panel information germane to Panel Passages.
 A Panel is created when a passage is tagged "panel" and configured inside the
 passage itself.

 @class Panel
 @constructor
**/

// Klembot included this stuff in the other files.
'use strict';
const $ = require('jquery');
const _ = require('underscore');
// var LZString = require('lz-string'); I do not know what this does :|
const Passage = require('./passage');
const Seqel = require('./seqel');
const Sequence = require('./sequence');
const PanelRenderer = require('./panelrenderer');
const ArtAsset = require('ArtAsset');

var Panel = function(name) {
  // ----- Basic Properties -----
  this.name = name;

  /**
	 Stores parent passage information

	 @property _parentPassage
	 @type PlainObject
	**/
  this.__parentPassage = {
    name: "",
    id: undefined
  }

  /**
	 Stores the CSS selectors relevant to this particular panel, so that in-panel
   jQuery can know about it.  Set up in Panelize.

	 @property _selectors
	 @type PlainObject
	**/
  this.__selectors = {
    passage: "",
    panel: ""
  }
  this.$ = function(){
    return $(this.__selectors.panel);
  }


  /* remembers whether the panel is complete; possibly spurious */
  this.__isComplete = false;

  // --- ART ---
  /**
	 the art object serves as an abstraction layer for art assets.  Properties
   take the form of { "semantic name": "path/of/art.png" } and are set with an
   addArt method.

	 @property art
	 @type Object
	**/

  this.art = {};
  var art = this.art;
  /**
   __ignoreRoot is used by addArtAssets.  It's a (private) boolean value that says whether or not we should check Twize for the globally set root art path, i.e., whether a user has flagged that they're not going to pass in the full path.

   __ignoreRoot starts out false and gets swapped to true via a public method of the same (non-underscored) name.

   @property __ignoreRoot, @property art.__ignoreRoot
   @method ignoreRoot
  **/
  art.__ignoreRoot = false;
  this.ignoreRoot = function () {
    this.art.__ignoreRoot = true;
  }

  /**
    The renderer manages the showing of art assets and running step animations.

    @property renderer
  **/

  this.renderer = new PanelRenderer();
  this.renderer.panelArtAssets = this.art;
  this.renderer._parentPanel = this;

  /**
	 I have big dreams for addArt being able to streamline art path management,
   but for now, this is just a glorified setter that makes sure none of our
   art properties have the same name.

	 @method addArt
   @param name {String} The semantic name of this art asset
   @param path {String} The path of this art asset
   @param filename {String} [optional] if passed this, `path` will be a
          directory, and `filename` the local file target.
            Currently, in my prototypes, `path` is getting set for the whole
          story as a machine-wide address for the art assets.  I like that and
          would like it even more if it weren't defined in the "user-defined
          JavaScript" on all of my stories.

   @returns Nothing, but possibly this should also return the art asset?
	**/

  this.addArt = function(key,path,filename) {
    var data;

    if (this.art[key]) {
      throw new Error (
        'There is already an art asset in this panel with the name "' + key + '"'
      );
    } else {
      data = {
        name: key,
        type: "image"
      };

      if (filename &amp;&amp; path) {
        data.useRoot = false;
        data.src = path + filename;
      } else {
        data.useRoot = true;
        data.src = path;
      }

      this.art[key] = new ArtAsset(data);
    }
  }

  /**
    addArtAssets is a streamlined method for adding many art assets at once. In the future, we may have multiple different types of art assets, but for now it's just images on layers.

    addArtAssets expects to get some number of arrays, all of length 2, where the first element is the name of the art asset and the second element is the path.  If we've flagged useRoot, addArtAssets will go get the rootArtPath from Twize.  Then, for each art asset, we addArt.
  **/

  this.addArtAssets = function __Panel__addArtAssets () {
    var assets, useRootArtPath, p;
    p = this;

    assets = Array.from(arguments);
    useRootArtPath = !art.__ignoreRoot;

    _.each(assets, function(asset) {
      // backwards compatible: arrays are made into standard 'image' type assets
      if(_(asset).isArray()) {
        var assetName, assetPath;
        assetName = asset[0];
        assetPath = asset[1];
        art[assetName] = new ArtAsset({
          name: assetName,
          src: assetPath,
          useRoot: useRootArtPath
        });
      } else {
        if(_(asset).isObject()) {
          asset.useRoot = (asset.useRoot === undefined) ? useRootArtPath : asset.useRoot;
          art[asset.name] = new ArtAsset(asset);
        }
      }
    })
  }

  // --- LAYERS ---
  /**
   An array of strings defining the layers (by way of their names) where
   overlapping panel art can be displayed.

   Possibly someday layers can be "grouped" into sub-arrays within `layers`,
   but for now it's just a buncha strings.

	 @property layers
	 @type Array
	**/

  this.layers = [];

  /**
	 Adds a new layer to the layers[] object.  Post-processes the name into a
   valid CSS selector, then checks if it's a dupe, then adds it to the layers.

	 @method addLayer
   @param name
	**/

  this.addLayer = function __Panel__addLayer (name) {
    var newLayerName;

    if ( (!name) || (typeof name !== "string") ) {
      throw new Error("Panel.addLayer: Bad argument passed to addLayer. Please give addLayer a string. Value:" + name)
    }

    newLayerName = _.wiz_validCssName(name);

    if( _.find(this.layers, function(existingLayer, proposedNewLayer) { return existingLayer == proposedNewLayer; }) ) {
      throw new Error("Panel.addLayer: The layer you're trying to add either has literally the same name as another layer, or does so when it gets processed into a CSS-friendly name. Sorry!\n\nProblem Name: " + newLayerName)
    } else {
      this.layers.push(newLayerName);
    }
  }

  /**
   Embarrassingly similar to Panel.addArtAssets, Panel.addLayers is an expedient way to add a bunch of layers at once.  It expects an indefinite number of strings as arguments.
  **/

  this.addLayers = function __Panel__addMultipleLayers() {
    var p = this;
    var layers;
    layers = Array.from(arguments);

    _.each(layers, function(layerName) {
      p.addLayer(layerName);
    })
  }

  // --- SEQUENCE ---
  /**
    0.1 --
	 " The sequence represents both the composition and "animation" of a Panel: in
   addition to describing the order, timing, and placement of art in an
   'iterative panel', it also describes the setup and placement of multi-layer
   static panel art. "
    0.2 --
   Nowadays (in this branch) the sequence is a lot more robust than that.
   It knows how to make Sequence Elements of all sorts, knows where we are
   in the sequence, all sorts of stuff.

	 @property seq
	 @type Sequence
	**/

  this.seq = new Sequence();

  /**
   step is a top-level semantic pseudonym / namespace for Seqel creation.  Possibly at some point we'll hide the concept of a seqel entirely from the frontend user.  I also don't know if this will work, so hold onto your butts!

   @property step
  **/

  this.step = {};
  this.step.create = _.bind(this.seq.addStep, this.seq);

  // --- DESTINATIONS ---
  /**
	 An abstraction layer which holds passage links.  Yes, specifically passage
   links---specified in the passage.  This is so Twine UI recognizes the
   network of linked passages.

	 @property destination
	 @type Object
	**/

  this.destination = {};

  //  -----  WORKHORSE METHODS  -----
  /**
   (Setup Method)
	 The method which sets up initial DOM structure for a panel.

	 @method setupStructure
   @param passage {String} the selector for the passage in which the panel will
          be created.
   @returns the newly-created div.panel within the panel object
	**/

  this.setupStructure = function(passage) {
    var panelDiv;

    if (!passage) {
      throw new Error(
        "Panel.setupStructure(): No Parameter supplied.  Panel.setupStructure() must take the selector of the DOM element in which the panel elements will be created."
      );
    }

    panelDiv = document.createElement('div');
    panelDiv.className = "panel";

    if ($(passage).length == 0) {
      throw new Error( "Panel.setupStructure: No passage div can be found in the DOM that maches the passed selector: " + passage+ ".\n\n(Panels selector errors may be caused by Panelizing before the document is ready.  Try wrapping your Panelize in Snowman's $() helper )" );
    } else {
      $(passage).append(panelDiv);
    }
  };

  /**
	 The method which creates art layers within a panel.

	 @method layerize
   @param specificLayer {String} a specific layer to layerize, rather than all layers at once.
	**/

  this.layerize = function(specificLayer) {
    var layers, $panel;
    var createLayer;

    $panel = this.__selectors.panel;
    layers = this.layers;

    if ($($panel).length == 0) {
      throw new Error( "Panel.layerize(): No panel can be found that maches the passed selector: " + $panel + ".\n\n(Panels selector errors may be caused by Panelizing before the document is ready.  Try wrapping your Panelize in Snowman's $() helper )" );
    }

    createLayer = function __layerize__createLayer(name) {
      var newLayer, layerExists;

      newLayer = document.createElement("div");
      newLayer.className = "layer " + name;

      layerExists = $($panel + " .layer." + name).length;
      if (!layerExists) {
        $($panel).append(newLayer);
      }
    }

    if(specificLayer) {
      createLayer(specificLayer)
    } else {
      if(layers.length == 0) {
        layers.push("default");
      }

      _.forEach(layers, _.bind(function(layerName) {
          createLayer(layerName);
        }, this)
      );
    }

    // console.log(this.art.__displayedAssets)
  };

  /**
	 The method which manages the Wand.  If it can't find a wand, it creates one;
   otherwise, it moves the existing wand from wherever it is to the
   active panel.
   Possibly someday this also adds all kinds of listeners and whatnot, but for
   now it just does what I said it does.
     I briefly considered calling this method "Ollivander"

	 @method wandize
	**/

  this.wandize = function() {
    var wand, wandExists, latestInstance;

    latestInstance = window.story.history.length - 1; // the dumb version.
    // it's also true, though.  That will probably always be correct?  But it smells funny to assume so.

    // latestInstance = _.wiz_findInHistory() // exists but isn't a thing yet.

    wand = $("#wand");
    wandExists = wand.length; // semantics!

    if(wandExists) {
      wand.appendTo(".passage.active[historyIndex="+latestInstance+"] .panel");
    } else {
      wand = document.createElement("div")
      wand.id = "wand"

      var latestPanel = $(".passage.active[historyIndex="+latestInstance+"] .panel")
      if (latestPanel.length) {
        latestPanel.append(wand);
      } else {
        throw new Error("Wandize couldn't find an active passage of history index "+latestInstance+" bearing a panel.  Sorry!")
      }
    }

    // this next bit is all highly suspect
    if(this.__isComplete) {
      if(!this.destination.main) {
        throw new Error("No main destination set.")
      }
      // this part immediately transforms the wand into a link to the next passage by Passage.render()-ing the passage link string stored in the destination
      $("#wand").html(Passage.render(this.destination.main)).removeClass("incomplete").addClass("complete");;
      $("#wand a").unwrap(); // removes vestigial p tag that accompanies this
    } else {
      // this, I assure you, is the most suspect of all
      $('#wand').html("&lt;a href='javascript:void(0)' onClick='window.passage.panel.advance()'>&lt;/a>").removeClass("complete").addClass("incomplete");
      // the onclick is moderately naughty.
    }
  };

  /**
	 Advance is the workhorse for handling sequential action in a Panel.  in 0.5, Advance delegates its behaviors among its children, and basically just oversees everything and makes sure nobody gets too big for their britches.  As such, it's quite lean.

	 @method advance
	**/

  this.advance = function() {
    var stepData, stepAnimation,
    step, newPosIndex, isFinalStep;

    stepData = this.seq.getStepData();
      step = stepData.step;
      newPosIndex = stepData.data.lastIndex + 1;
      isFinalStep = stepData.data.isFinalStep;
    stepAnimation = this.renderer.createStepAnimation(step);

    this.renderer.animate(stepAnimation);

    // this should be evented somehow.  it temporarily fixes final advancement, though.
    this.seq.pos.index = newPosIndex;
    this.__isComplete = isFinalStep;
  }

  // ----- DISPLAY METHODS -----
  /**
	 Adds an art asset to a layer in the panel.

	 @method show
   @param artAssetName {String} the name of the art asset to show.
   @param layerName {String} the name of the layer on which to show the asset.
	**/

  this.show = function (artAssetName,layerName) {
    var $passage, $panel, $layer, artAssetPath;

    $passage = $(this.__selectors.passage);
    $panel = $(this.__selectors.panel);
    $layer = $panel.find(".layer."+layerName);
    artAssetPath = this.art[artAssetName];

    if(artAssetPath) {
      var newAsset = document.createElement('img')
      // newAsset.setAttribute('src', artAssetPath);
      $layer.append("&lt;img artasset='"+artAssetName+"' src='" + artAssetPath + "' />")
      // $layer.append(newAsset);
      return $layer.find("img[artasset='"+artAssetName+"']");
    } else {
      throw new Error( "Panel.show(): Could not find an art asset with the name '"+artAssetName+"'" )
    }
  }

  /**
	 Replaces the entirety of a layer with an art asset.  In 0.3 this is identical
   to Panel.show except that it uses .html instead of .append

   in 0.4 we're removing this in favor of handling it elsewhere

	 @method replace
   @param artAssetName {String} the name of the art asset to add to the layer.
   @param layerName {String} the name of the layer to clear and replace with the asset.
	**/

  this.replace = function (artAssetName,layerName) {
    var $passage, $panel, $layer, artAssetPath;

    $passage = $(this.__selectors.passage);
    $panel = $(this.__selectors.panel);
    $layer = $panel.find(".layer."+layerName);
    artAssetPath = this.art[artAssetName];

    if(artAssetPath) {
      return $layer.html("&lt;img src='" + artAssetPath + "' />")
    } else {
      throw new Error( "Panel.show(): Could not find an art asset with the name '"+artAssetName+"'" )
    }
  }

  /**
	 Removes an art asset from a layer.

	 @method remove
   @param artAssetName {String} the name of the art asset to remove from the layer.
   @param layerName {String} the name of the layer where the art asset can be found.
	**/

  this.remove = function (assetNamesParam,layerName) {
    var $passage, $panel, $layer, assetNames;

    if(_.isString(assetNamesParam)) {
      assetNames = [assetNamesParam];
    } else if (_.isArray(assetNamesParam)) {
      assetNames = assetNamesParam;
    } else {
      throw new Error("Invalid param passed to Panel.remove: takes either asset name as string or an array (of asset name strings, but I'm not checking for that, so behave yourselves, kids)");
    }

    $passage = $(this.__selectors.passage);
    $panel = $(this.__selectors.panel);
    $layer = $panel.find(".layer."+layerName);
    _.each(assetNames, function(artAssetName){
      $layer.find("img[artasset='"+artAssetName+"']").remove();
    });
  }

  /**
	 Finds elements that currently exist in the DOM panel.  Can either get a specific art asset, or

	 @method _getDisplayed
	**/

  this.__getDisplayed = function(artAssetName,layerName) {
    var $panel, $layer, artAssetPath, trash;

    if (!artAssetName) {
      if(!layerName) {
        throw new Error("Panel.__getDisplayed: No params passed.  This expects artAssetName and layerName.")
      }
      // then we're getting everything on the layer
      artAssetName = "__all__"
    }

    $panel = $(this.__selectors.panel);
    if (layerName) {
      $layer = $panel.find(".layer."+layerName);
    }

    if(_.has(this.art, artAssetName)) {
      var $context, foundAsset;

      artAssetPath = this.art[artAssetName];
      $context = $layer ? $layer : $panel;

      foundAsset = $context.find("img[artasset='"+artAssetName+"']");
      if (foundAsset) {
        return foundAsset;
      } else {
        throw new Error("Panel.__getDisplayed couldn't find an img within the DOM panel bearing the name of that art asset.")
      }
    } else if(artAssetName == "__all__") {
      // console.log(document.querySelectorAll(this.__selectors.panel))
      // console.log(document.querySelectorAll(this.__selectors.panel+ ' .layer'))

      return document.querySelectorAll(this.__selectors.panel + ' .layer.'+layerName+' img');

    } else {
      throw new Error("The art asset name given to Panel.__getDisplayed doesn't seem to exist in this panel's art object.");
    }
  }

  this.refresh = function(){
    this.seq.updatePos(0, "default");
    this.renderer.refresh();
  }
}

// Some Twize-Specific extensions to the Passage

_.extend(Passage.prototype, {
  /**
	 The function which creates a panel on a passage object.  For the moment, I'm
   going to advocate calling this

	 @method panelize
   @param initializeData { Function }  [optional] A function which initializes panel
   data.  This function is provided the newly-created Panel as a param.
   @returns the panel object.
	**/

  panelize: function(initializeData){
    var panel, passageSelector, panelSelector;

    if(this.panel) {
      // check to see if this passage already has a panel
      panel = this.panel;
      panel.refresh();
    }
    else {
      // begin panel creation:
      // (if we don't have a panel, we make a new one)
      this.panel = new Panel(this.name);
      panel = this.panel;

      if (initializeData) {
        if (typeof initializeData !== "function") {
          throw new Error(
            'Panel.panelize(): Panelize only takes a function as a param.  You passed a param of type "' + (typeof initializeData) + '".'
          );
        } else {
          initializeData(panel);
        }
      } else {
        console.log( "Panel.panelize(): You Panelized the panel of Passage \"" + this.name + "\" without passing a function to set up its data.  This is allowed, but not recommended; a Panel's data should be set up in its entirety during Panelization.")
      }

      // create default info?  This really depends on how static panels are, and whether you're going to be configuring them some more later on
    }

    // Render Panel In Passage

    // panel.__selectors.passage = passageSelector = ".passage.active." + this.passageDomName() + "[historyIndex=\'"+(window.story.history.length-1)+"\']";
    // panel.__selectors.panel = panelSelector = passageSelector + " .panel";
    panel.__selectors.passage = passageSelector = "."+this.passageDomName() + "[historyIndex=\'"+(window.story.history.length-1)+"\']";
    panel.__selectors.panel = panelSelector = passageSelector + " .panel";
    panel.renderer.selectors = panel.__selectors;

    panel.setupStructure(passageSelector);
    // add layers (in 0.1, create a single default layer)
    panel.layerize();
    // stick the wand on the panel, or create one.
    panel.advance();

    $.event.trigger('panelized', panel);
    $(document).on("click", panelSelector+".wand.active", function() {
      panel.$().trigger('panel-clicked', panel);
    })
    return panel;
  },

  /**
	 A helper function which will output the standard CSS identifier for this
   passage, or for another passage that exists.

	 @method passageDomName
   @param otherPassage { Object } [optional] A passage other than this one.
   @returns A string with a standardized name for this passage.
	**/

  passageDomName: function(otherPassage) {
    var prefix, passageName, suffix,
        validPassageName;

    prefix = "passage--";
    passageName = (otherPassage) ? otherPassage.name : this.name;
    suffix = "";

    validPassageName = _.wiz_validCssName(passageName);

    return prefix + validPassageName + suffix;
  }
});

module.exports = Panel;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ArtAsset.html">ArtAsset</a></li><li><a href="PanelRenderer.html">PanelRenderer</a></li><li><a href="Seqel.html">Seqel</a></li><li><a href="Sequence.html">Sequence</a></li><li><a href="Story.html">Story</a></li><li><a href="Twize.html">Twize</a></li></ul><h3>Events</h3><ul><li><a href="global.html#event:animation-begun">animation-begun</a></li><li><a href="global.html#event:checkpoint">checkpoint</a></li><li><a href="global.html#event:checkpointfailed">checkpointfailed</a></li><li><a href="global.html#event:hidepassage">hidepassage</a></li><li><a href="global.html#event:restore">restore</a></li><li><a href="global.html#event:restorefailed">restorefailed</a></li><li><a href="global.html#event:save">save</a></li><li><a href="global.html#event:showpassage">showpassage</a></li><li><a href="global.html#event:startstory">startstory</a></li><li><a href="global.html#event:restore:after">restore:after</a></li><li><a href="global.html#event:showpassage:after">showpassage:after</a></li></ul><h3>Namespaces</h3><ul><li><a href="-_.html">_</a></li></ul><h3>Mixins</h3><ul><li><a href="Underscore.hasAll.html">hasAll</a></li><li><a href="Underscore.hasOnly.html">hasOnly</a></li><li><a href="Underscore.xor.html">xor</a></li><li><a href="Underscore-thumbprint.html">thumbprint</a></li></ul><h3>Global</h3><ul><li><a href="global.html#__parentPassage">__parentPassage</a></li><li><a href="global.html#__selectors">__selectors</a></li><li><a href="global.html#__settings">__settings</a></li><li><a href="global.html#_getDisplayed">_getDisplayed</a></li><li><a href="global.html#_layers">_layers</a></li><li><a href="global.html#_loadingAssets">_loadingAssets</a></li><li><a href="global.html#addArt">addArt</a></li><li><a href="global.html#addArtAssets">addArtAssets</a></li><li><a href="global.html#addBeatPushesanewsequencebeattotheAssetAnimation'ssequence.">addBeat

   Pushes a new sequence beat to the AssetAnimation's sequence.</a></li><li><a href="global.html#addLayer">addLayer</a></li><li><a href="global.html#addLayers">addLayers</a></li><li><a href="global.html#addSeqeltheSeqelconstructortakesvariablearguments,sothisbasicSeqel-makerdoestoo.---2arguments:---">addSeqel
   the Seqel constructor takes variable arguments, so this basic Seqel-maker
   does too.
   --- 2 arguments: ---</a></li><li><a href="global.html#addStep">addStep</a></li><li><a href="global.html#addUnknownLayers">addUnknownLayers</a></li><li><a href="global.html#advance">advance</a></li><li><a href="global.html#animate">animate</a></li><li><a href="global.html#art">art</a></li><li><a href="global.html#asset">asset</a></li><li><a href="global.html#assetFindsthefirstinstanceofanassetmatchingthequeryparamanywhereintheShadowPanel.">asset

   Finds the first instance of an asset matching the query param anywhere in the ShadowPanel.</a></li><li><a href="global.html#assetRecords">assetRecords</a></li><li><a href="global.html#beats">beats</a></li><li><a href="global.html#checkpoint">checkpoint</a></li><li><a href="global.html#checkpointName">checkpointName</a></li><li><a href="global.html#createLayerInstanceSpecializedlayercreation.">createLayerInstance

   Specialized layer creation.</a></li><li><a href="global.html#createStepAnimation">createStepAnimation</a></li><li><a href="global.html#creator">creator</a></li><li><a href="global.html#creatorVersion">creatorVersion</a></li><li><a href="global.html#destination">destination</a></li><li><a href="global.html#errorMessage">errorMessage</a></li><li><a href="global.html#getArtAsset">getArtAsset</a></li><li><a href="global.html#getDefault">getDefault</a></li><li><a href="global.html#history">history</a></li><li><a href="global.html#id">id</a></li><li><a href="global.html#ignoreErrors">ignoreErrors</a></li><li><a href="global.html#ignoreRoot">ignoreRoot</a></li><li><a href="global.html#layerGetsalayerfromtheshadowPanel.">layer

   Gets a layer from the shadowPanel.</a></li><li><a href="global.html#layerize">layerize</a></li><li><a href="global.html#layers">layers</a></li><li><a href="global.html#name">name</a></li><li><a href="global.html#panelize">panelize</a></li><li><a href="global.html#passage">passage</a></li><li><a href="global.html#passageDomName">passageDomName</a></li><li><a href="global.html#passages">passages</a></li><li><a href="global.html#pos">pos</a></li><li><a href="global.html#remove">remove</a></li><li><a href="global.html#render">render</a></li><li><a href="global.html#renderer">renderer</a></li><li><a href="global.html#rendererId">rendererId</a></li><li><a href="global.html#replace">replace</a></li><li><a href="global.html#restore">restore</a></li><li><a href="global.html#save">save</a></li><li><a href="global.html#saveHash">saveHash</a></li><li><a href="global.html#selectors">selectors</a></li><li><a href="global.html#seq">seq</a></li><li><a href="global.html#setDefaults">setDefaults</a></li><li><a href="global.html#setup">setup</a></li><li><a href="global.html#setupStructure">setupStructure</a></li><li><a href="global.html#show">show</a></li><li><a href="global.html#source">source</a></li><li><a href="global.html#start">start</a></li><li><a href="global.html#startPassage">startPassage</a></li><li><a href="global.html#state">state</a></li><li><a href="global.html#step">step</a></li><li><a href="global.html#tags">tags</a></li><li><a href="global.html#tracks">tracks</a></li><li><a href="global.html#userScripts">userScripts</a></li><li><a href="global.html#userStyles">userStyles</a></li><li><a href="global.html#wandize">wandize</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Thu Mar 16 2017 12:58:43 GMT-0700 (Pacific Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
